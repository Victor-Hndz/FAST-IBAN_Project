int combine_groups(selected_point_group *groups, int n_groups, int i, int j) {
    //selected_point_group *new_groups = malloc((n_groups-1)*sizeof(selected_point_group));
    selected_point *aux_points = malloc((groups[i].n_points + groups[j].n_points)*sizeof(selected_point));
    double rmsd_actual, dist=0;

    for(int k=0; k<groups[i].n_points; k++) 
        aux_points[k] = groups[i].points[k];

    for(int k=0; k<groups[j].n_points; k++) 
        aux_points[groups[i].n_points + k] = groups[j].points[k];

    //RMSD de los puntos combinados - distancia media de cada punto respecto al nuevo > 0.
    rmsd_actual = calculate_rmsd(aux_points, groups[i].n_points + groups[j].n_points);
    
    for(int i=0; i<groups[j].n_points; i++) 
        dist += groups_mean_distance(groups[i], groups[j].points[i]);

    dist /= groups[j].n_points;

    printf("RMSD: %.6f, Distancia: %.6f\n", rmsd_actual, dist);

    if(rmsd_actual - dist >= 0) {
        groups[i].n_points += groups[j].n_points;
        groups[i].rmsd = rmsd_actual;
        groups[i].points = aux_points;

        //free(groups[j].points);
        for(int k=j; k<n_groups-1; k++) 
            groups[k] = groups[k+1];

        groups = realloc(groups, (n_groups-1)*sizeof(selected_point_group));

        n_groups--;
    } else 
        free(aux_points);

    return n_groups;
}


